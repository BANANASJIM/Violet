#version 450

// Luminance Histogram Compute Shader
// Builds a 64-bin histogram of log2 luminance for robust auto-exposure
// Reference: https://alextardif.com/HistogramLuminance.html
//            https://bruop.github.io/exposure/

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Input: HDR scene color
layout(set = 0, binding = 0) uniform sampler2D hdrScene;

// Output: Histogram buffer (64 bins)
layout(set = 0, binding = 1) buffer HistogramBuffer {
    uint bins[64];           // Histogram bins (atomic counters)
    float minLogLuminance;   // Minimum log2 luminance in range (e.g., -4.0)
    float maxLogLuminance;   // Maximum log2 luminance in range (e.g., 12.0)
    uint pixelCount;         // Total pixels processed
} histogram;

// Push constants for parameters
layout(push_constant) uniform HistogramParams {
    float minLogLum;         // -4.0 (covers very dark scenes)
    float maxLogLum;         // 12.0 (covers very bright scenes)
    float centerWeightPower; // 2.0 (Gaussian-like center weighting, 0 = uniform)
    uint enabled;            // 1 = enabled, 0 = disabled
} params;

// Shared memory for local histogram (reduce global atomics)
shared uint localHistogram[64];

// Rec. 709 luminance weights
float getLuminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

// Center-weighted metering: higher weight for screen center
// Uses distance-based falloff (similar to Gaussian)
float getCenterWeight(vec2 uv) {
    if (params.centerWeightPower <= 0.0) {
        return 1.0; // Uniform weighting
    }

    // Distance from center [0, 1]
    vec2 centerOffset = uv - 0.5;
    float dist = length(centerOffset) * 2.0; // Normalize to [0, 1]

    // Gaussian-like falloff: weight = exp(-k * dist^2)
    // Using power instead for performance: weight = (1 - dist)^power
    float weight = pow(max(0.0, 1.0 - dist), params.centerWeightPower);
    return weight;
}

void main() {
    uint localIdx = gl_LocalInvocationID.y * 16 + gl_LocalInvocationID.x;

    // Initialize local histogram
    if (localIdx < 64) {
        localHistogram[localIdx] = 0;
    }
    barrier();

    // Get texture coordinates
    ivec2 texSize = textureSize(hdrScene, 0);
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    // Check bounds
    if (pixelCoord.x >= texSize.x || pixelCoord.y >= texSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(texSize);

    // Sample HDR scene
    vec3 color = texture(hdrScene, uv).rgb;

    // Calculate luminance
    float lum = getLuminance(color);

    // Skip very dark/invalid pixels
    if (lum < 0.001) {
        return;
    }

    // Log2 luminance for perceptual distribution
    float logLum = log2(lum);

    // Map to histogram bin [0, 63]
    float range = params.maxLogLum - params.minLogLum;
    float normalizedLogLum = (logLum - params.minLogLum) / range;
    int binIndex = int(normalizedLogLum * 64.0);
    binIndex = clamp(binIndex, 0, 63);

    // Center-weighted metering
    float weight = getCenterWeight(uv);
    uint weightedCount = uint(weight * 256.0); // Scale to integer for atomics

    if (weightedCount > 0) {
        // Accumulate in local histogram (shared memory)
        atomicAdd(localHistogram[binIndex], weightedCount);
    }

    barrier();

    // First 64 threads write local histogram to global
    if (localIdx < 64) {
        if (localHistogram[localIdx] > 0) {
            atomicAdd(histogram.bins[localIdx], localHistogram[localIdx]);
        }
    }

    // First thread updates metadata
    if (gl_LocalInvocationID.xy == uvec2(0, 0)) {
        uint workgroupPixels = 16 * 16;
        atomicAdd(histogram.pixelCount, workgroupPixels);
    }
}