#version 450

// Optimized workgroup size: process all 6 faces in one dispatch using Z dimension
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Input: Equirectangular HDR texture
layout(set = 0, binding = 0) uniform sampler2D equirectangularMap;

// Output: Cubemap storage image
layout(set = 0, binding = 1, rgba16f) uniform imageCube outputCubemap;

// Push constants for cubemap size (currentFace removed - using gl_GlobalInvocationID.z)
layout(push_constant) uniform PushConstants {
    uint cubemapSize;
} pc;

const float PI = 3.14159265359;

// Convert cubemap UV coordinates to 3D direction vector
vec3 uvToDirection(vec2 uv, uint face) {
    // Map UV from [0, 1] to [-1, 1]
    vec2 ndc = uv * 2.0 - 1.0;

    vec3 dir;
    switch (face) {
        case 0: dir = vec3( 1.0, -ndc.y, -ndc.x); break; // +X
        case 1: dir = vec3(-1.0, -ndc.y,  ndc.x); break; // -X
        case 2: dir = vec3( ndc.x,  1.0,  ndc.y); break; // +Y
        case 3: dir = vec3( ndc.x, -1.0, -ndc.y); break; // -Y
        case 4: dir = vec3( ndc.x, -ndc.y,  1.0); break; // +Z
        case 5: dir = vec3(-ndc.x, -ndc.y, -1.0); break; // -Z
    }

    return normalize(dir);
}

// Convert 3D direction to equirectangular UV coordinates
vec2 directionToEquirectUV(vec3 dir) {
    // Calculate spherical coordinates
    // Theta (longitude): measured from +X axis around Y axis, range [-π, π]
    float theta = atan(dir.z, dir.x);

    // Phi (latitude): measured from +Y axis (north pole) downward, range [0, π]
    // Use acos instead of asin to get full [0, π] range
    // Clamp to prevent numerical errors outside [-1, 1]
    float phi = acos(clamp(dir.y, -1.0, 1.0));

    // Convert to UV coordinates [0, 1]
    float u = (theta + PI) / (2.0 * PI);  // Map [-π, π] → [0, 1]
    float v = 1.0 - phi / PI;              // Map [0, π] → [1, 0] (flip V to correct upside-down)

    return vec2(u, v);
}

void main() {
    // Get current pixel coordinates (Z = face index)
    ivec3 globalId = ivec3(gl_GlobalInvocationID);
    ivec2 pixelCoord = globalId.xy;
    uint currentFace = globalId.z;

    // Check bounds
    if (pixelCoord.x >= pc.cubemapSize || pixelCoord.y >= pc.cubemapSize || currentFace >= 6) {
        return;
    }

    // Calculate UV for this pixel (center of pixel)
    vec2 uv = (vec2(pixelCoord) + 0.5) / float(pc.cubemapSize);

    // Get 3D direction for this cubemap pixel
    vec3 direction = uvToDirection(uv, currentFace);

    // Convert direction to equirectangular UV
    vec2 equirectUV = directionToEquirectUV(direction);

    // Sample from equirectangular map
    vec4 color = texture(equirectangularMap, equirectUV);

    // Write to cubemap face (all 6 faces processed in parallel)
    imageStore(outputCubemap, ivec3(pixelCoord, currentFace), color);
}
