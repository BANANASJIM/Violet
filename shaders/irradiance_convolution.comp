#version 450

// Workgroup size for processing cubemap faces
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Input: Environment cubemap
layout(set = 0, binding = 0) uniform samplerCube environmentMap;

// Output: Irradiance cubemap (lower resolution)
layout(set = 0, binding = 1, rgba16f) uniform imageCube irradianceMap;

// Push constants for cubemap size and current face
layout(push_constant) uniform PushConstants {
    uint irradianceSize;
    uint currentFace;
} pc;

const float PI = 3.14159265359;

// Convert cubemap UV coordinates to 3D direction vector
vec3 uvToDirection(vec2 uv, uint face) {
    // Map UV from [0, 1] to [-1, 1]
    vec2 ndc = uv * 2.0 - 1.0;

    vec3 dir;
    switch (face) {
        case 0: dir = vec3( 1.0, -ndc.y, -ndc.x); break; // +X
        case 1: dir = vec3(-1.0, -ndc.y,  ndc.x); break; // -X
        case 2: dir = vec3( ndc.x,  1.0,  ndc.y); break; // +Y
        case 3: dir = vec3( ndc.x, -1.0, -ndc.y); break; // -Y
        case 4: dir = vec3( ndc.x, -ndc.y,  1.0); break; // +Z
        case 5: dir = vec3(-ndc.x, -ndc.y, -1.0); break; // -Z
    }

    return normalize(dir);
}

// Build orthonormal basis from normal (Frisvad method)
void buildOrthonormalBasis(vec3 n, out vec3 tangent, out vec3 bitangent) {
    if (n.z < -0.9999999) {
        tangent = vec3(0.0, -1.0, 0.0);
        bitangent = vec3(-1.0, 0.0, 0.0);
        return;
    }
    float a = 1.0 / (1.0 + n.z);
    float b = -n.x * n.y * a;
    tangent = vec3(1.0 - n.x * n.x * a, b, -n.x);
    bitangent = vec3(b, 1.0 - n.y * n.y * a, -n.y);
}

void main() {
    // Get current pixel coordinates
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    // Check bounds
    if (pixelCoord.x >= pc.irradianceSize || pixelCoord.y >= pc.irradianceSize) {
        return;
    }

    // Calculate UV for this pixel (center of pixel)
    vec2 uv = (vec2(pixelCoord) + 0.5) / float(pc.irradianceSize);

    // Get 3D normal direction for this cubemap pixel
    vec3 N = uvToDirection(uv, pc.currentFace);

    // Build tangent space
    vec3 T, B;
    buildOrthonormalBasis(N, T, B);

    // Convolve environment map - integrate over hemisphere
    vec3 irradiance = vec3(0.0);

    // Hemisphere sampling resolution
    const uint THETA_SAMPLES = 32u;  // Polar angle samples (latitude)
    const uint PHI_SAMPLES = 64u;    // Azimuthal angle samples (longitude)

    float totalWeight = 0.0;

    // Integrate using Riemann sum over hemisphere
    for (uint j = 0u; j < THETA_SAMPLES; ++j) {
        // Theta from 0 (pole) to PI/2 (horizon)
        float theta = (float(j) + 0.5) / float(THETA_SAMPLES) * (PI * 0.5);

        for (uint k = 0u; k < PHI_SAMPLES; ++k) {
            // Phi from 0 to 2*PI (full rotation around hemisphere)
            float phi = (float(k) + 0.5) / float(PHI_SAMPLES) * 2.0 * PI;

            // Convert spherical to cartesian (in tangent space)
            vec3 tangentSample = vec3(
                sin(theta) * cos(phi),
                sin(theta) * sin(phi),
                cos(theta)
            );

            // Transform to world space
            vec3 sampleDir = tangentSample.x * T + tangentSample.y * B + tangentSample.z * N;

            // Sample environment map
            vec3 sampleColor = texture(environmentMap, sampleDir).rgb;

            // Weight by cos(theta) * sin(theta) (solid angle measure)
            float cosTheta = cos(theta);
            irradiance += sampleColor * cosTheta * sin(theta);
            totalWeight += cosTheta * sin(theta);
        }
    }

    // Normalize by total weight and multiply by PI
    // The PI factor accounts for the hemisphere integration in the rendering equation
    // The diffuse BRDF term in the fragment shader is albedo/PI, so the final result is:
    // (irradiance * PI) * (albedo / PI) = irradiance * albedo (correct Lambert diffuse)
    irradiance = (PI * irradiance) / totalWeight;

    // Write to irradiance map
    imageStore(irradianceMap, ivec3(pixelCoord, pc.currentFace), vec4(irradiance, 1.0));
}
